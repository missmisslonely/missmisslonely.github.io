---
layout:     post
title:      五大算法设计技巧系列
subtitle:   五大算法设计技巧之分治、动态规划与贪心算法
date:       2020-2-18
author:     Sissi
header-img: 
catalog: true
tags:
   
---

>

# 五大算法设计技巧之分治、动态规划与贪心算法
## 分治算法

分：递归解决较小的问题

治：然后从子问题的解构建原问题的解

至少含有两个递归调用的叫做分治算法，子问题不相交

时间复杂度 如归并排序对两个问题进行运算，每个问题均是原问题大小的一半，然后用到O（N）的附加工作，由此公式如下
				
```
T（N）=2T（N/2）+O(N) 
解为O(NlogN)				
```
求解递归式方法：代入法，递归树主方法

《算法导论》经典题目：最大子数组问题，矩阵乘法的strassen算法

《数据结构与算法分析》里面的经典题目：最近点问题，选择问题（第K元素），归并排序，快速排序
## 动态规划
子问题不是原问题明显的分割，因为子问题反复被求解，所以需要一个表来记录而不是重新计算它们。**韦斯的黑皮书这么说明：将递归算法重新写成非递归算法，将子问题的答案系统的记录在一个表内，这种技巧叫做动态规划。**

三点要求：最优子结果，重叠子问题，状态转移方程求最值。

使用方法：自顶向下备忘录(数组或者hash表字典)和dp table，遇到动态规划问题可以画递归树。

```
《算法导论》黑皮书这样写到，通常按4个步骤设计动态规划算法：

1.刻画一个最优解的结构特征
2.递归地定义最优解的值
3.计算最优解的值，通常采用自底向上的方法
4.利用计算出的信息构造一个最优解

```

```
黑皮书还写到动态规划原理：

1.最优子结构，它的不同体现在两个方面：（1）原问题的最优解中涉及多少个子问题 
（2）在确定最优解使用哪些子问题时，我们需要考察多少种选择 
2.如果递归算法反复求解相同的子问题，称最优化问题具有重叠子问题性质
3.重构最优解，将每个子问题所做的选择存在一个表中，这样就不必根据代价值来重构这些信息 
4备忘， 如果每个子问题都必须至少求解一次，自底向上动态规划算法会比自顶向下备忘录算法快，因为自底向上算法没有递归调用的开销，表的维护开销也更小

```
找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解再查看有没有重叠子问题，有则优化，无则ok。

《算法导论》里面的经典动态规划题目是：钢条切割，矩阵链乘法，最长公共子序列，最优二叉搜索树。

《数据结构与算法分析》里面的经典动态规划题目：用一个表代替递归，矩阵乘法的顺序安排，最优二叉查找树，所有点对最短路径。
##贪心算法
贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划更高。暴力解法需要指数级时间，动态规划消除重叠子问题，可以降到多项式级别的时间，如果满足贪心选择性质，可以进一步降低时间复杂度，达到线性级别的。

它的每一步都做出当时看起来最佳的选择，总是做出局部最优的选择寄希望这样的选择能导出全局最优解。

```
设计此算法的过程：
1.将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解
2.证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。
3.证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优结构。
```
```
性质：
1.贪心选择性质
动态规划先求解子问题才能进行第一次选择不同，贪心算法在进行第一次选择之前不求解任何子问题。一个动态规划算法是自底向上进行计算的，而一个贪心算法通常是自顶向下的，进行一次又一次选择，将给定问题实例变得更小。
2.最优子结构
```
《算法导论》里面的经典贪心算法题目：活动选择问题，哈夫曼编码，拟阵求解任务调度问题。
《数据结构与算法分析》里面的经典题目：Dijkstra算法，Prim算法，Kruskal算法，简单调度问题，哈夫曼编码，近似装箱问题。

根据两本书可以看到几个重复的题目，需要重点掌握